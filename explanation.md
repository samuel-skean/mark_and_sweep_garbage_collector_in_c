For this assignment, we had to fill in parts of a simple garbage collector following the mark and sweep strategy. Whenever the garbage collector was invoked, it would follow all pointers to the heap from the stack and global variables (the two kinds of variables directly accessible to the program) recursively and mark those chunks on the heap as “reachable” by changing an otherwise-unused bit in the chunk’s size. This means it looks at each potential pointer in the code (that is, each 8-byte aligned sequence of 8 bytes), checks if it does point inside an in-use block on the heap by checking that it is within the bounds of the heap and looping through the blocks until it finds one that contains the pointer and is in use, and then changes the 2nd-least-significant bit of that block’s header to mark it as “reachable”. If it finds no such block, or the “pointer” is not within the bounds of the heap, it returns the null pointer, communicating that that 8-byte chunk is not, in fact, a pointer that the garbage collector needs to mark. Only pointers to the heap have their blocks marked because memory elsewhere in the program (in the globals and the stack) is handled otherwise. Pointers that point to a non-in-use block should also not be marked as reachable, since they are either simply 8-byte pieces of memory that happen to be interpretable as pointers, and therefore will not be used as such in the program, or they are pointers that have been freed, and therefore the program should not attempt to dereference them because that is undefined behavior - that block may be replaced by something else. Either way, the program won’t use those “pointers” as pointers and the garbage collector shouldn’t attempt to find any other pointers that might be accessible through them, as they should be considered unreachable, so it should be freed.

The recursion is achieved by, whenever the walking function finds a valid pointer, it calls itself on the bounds of the payload of the chunk that the pointer points inside of. The payload starts 4 bytes after the chunk pointer, which points to the header.

Then, it would “sweep” through every single chunk in the heap, checking if it is marked. This is effectively looping through the chunks. If a chunk is marked, it would remove the mark so that it is not assumed to be reachable the next time the garbage collector runs. If the chunk is not marked, it is known to not be reachable, so it is freed.

That’s about all this code does!

Addendum:
This garbage collector is technically [*conservative*](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Precise_vs._conservative_and_internal_pointers) - it errs on the side of not freeing memory, even when it *might* be okay to free memory. For the garbage collector to avoid freeing memory that it should free, that memory location would have to be:
- Allocated on the heap in an in-use chunk, or something whose memory looks like an in-use chunk. The second case seems very unlikely since when we walk the chunks in the heap, we can really only end up in valid chunks. See the function `next_chunk` in hw4.c to verify this claim.
  -  That in-use chunk must not be reachable through any actual pointer.
-  Have its address stored in some variable in reachable memory that will never be used as an address. This seems unlikely, since heap memory addresses are pretty large numbers and there are a lot of them. How likely is it that we'll have a `long` in our code with the value `0x600000f20020`, for example?
You can look at the function `is_pointer` in hw4.c to verify my conclusions.

Because C does not store any data that enables you to check if a pointer really is a pointer, it's really impossible to make this collector *exact* - freeing exactly the memory it can, no more and no less - at least I think so. As far as I am aware, there are no exact garbage collectors for C, C++, or similar languages for this reason - the [Boehm garbage collector](https://en.wikipedia.org/wiki/Boehm_garbage_collector) is a conservative one, for instance.
Since it can't be exact, the only correct choice is to be conservative. Otherwise, we might free memory that's in use and cause a use-after-free error! That's no good. If only politics were so simple...